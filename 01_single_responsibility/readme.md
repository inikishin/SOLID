# Single responsibility (SRP) - принцип единственной ответсвенности

Классы должны иметь одну и только одну причину для изменений.

или

Модуль должен отвечать за одного и только за одного пользователя или группу лиц, заинтересованных в изменениях.

Допустим, перед вами стоит задача: написать код, который превратит грязное бельё в чистое. Если структурировать код, отталкиваясь только от задания, у вас, скорее всего, получится примерно такой класс:

```python
class RefreshClothes:
    def put clothes
    def add washing powder
    def add conditioner
    def select washing mode
    def start washing
    def take out clothes

    def hang on the dryer
    def wait until dry
    def remove from dryer

    def turn on the iron
    def put clothes on the ironing board
    def smooth out creases
    def turn off the iron

    def start
```

У этого класса много ответственных задач: он должен уметь правильно пользоваться стиральной машиной, сушилкой и утюгом, а ещё выполнять действия в правильном порядке. Но если любой из этих процессов изменится, вам придётся править этот код: например, вместо стирального порошка вы начнёте пользоваться жидким средством или вместо утюга купите отпариватель.

Чтобы проверить, нарушен ли принцип SRP, попробуйте описать то, чем занимается этот класс, в одном предложении. Получится что-то вроде: «Он стирает, сушит и гладит одежду». Наличие перечисления и союзов «и» — один из признаков возможного нарушения принципа единой ответственности. Наглядный пример нарушения принципа — паттерн Singleton. Такой класс выполняет две задачи: следит за тем, чтобы в программе был только один экземпляр, и выполняет какие-то полезные действия.

Давайте избавимся от перечисления, разбив код на несколько отдельных классов.

```python
class Wash
    def put clothes
    def add washing powder
    def add conditioner
    def select washing mode
    def start washing
    def take out clothes
    def start

class Dry
    def hang on the dryer
    def wait until dry
    def remove from dryer
    def start

class Smooth
    def turn on the iron
    def put clothes on the ironing board
    def smooth out creases
    def turn off the iron
    def start

class RefreshClothes
    def start 
```

Теперь стиркой занимается класс Wash, сушкой — класс Dry, глажкой — класс Smooth, а за запуск процесса отвечает RefreshClothes. Если в классе Wash найдётся ошибка, ваши исправления не затронут работающий код, потому что он находится в другом классе.

Например, при написании API нарушением SRP будет совмещение кода валидации поступивших данных, их обработки, записи в базу и формирования ответа. У вас получится Божественный объект — универсальный код, который умеет делать всё.

Вторая формулировка принципа предлагает задуматься, от кого к вам поступит следующая просьба исправить этот код. Код пишется для каких-то потребителей. Это может быть конкретный человек, например, главбух, или группа лиц — отдел контент-менеджеров. Такие группы лиц называются акторами. Принцип советует разделять сущности, изменения в которых нужны только разным акторам. Группировка кода для разных акторов в одном модуле приведёт к сложностям, если их требования к коду перестанут совпадать.

Например, в вашем онлайн-кинотеатре есть API, который используют администраторы сайта и посетители.

Администраторы не используют методы /favorites, /search, /comments и /profile. А пользователям неинтересен раздел /users. Если требования к API со стороны администраторов изменится, то из-за скрещённой между собой логики вы измените и код для пользователя. Чтобы избавиться от обобщённых участков, лучше разделить API на две части, отдельные для каждого актора.

Вас может возмутить потенциальное дублирование кода. Но со временем требования к одной из частей могут кардинально измениться, и изначально одинаковый код станет совсем непохож на своего брата.

SRP весьма универсален. Он понадобится вам в проектировании системы любого масштаба: от микросервисов до отдельных функций.

Нарушение SRP ускоряет разработку в начале проекта, но сильно замедляет по мере его роста. Разбить уже существующий класс гораздо труднее, чем поддерживать нескольких отдельных сущностей, поэтому стоит приложить усилия к декомпозиции кода на ранних этапах разработки.
