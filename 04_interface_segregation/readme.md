# Interface Segregation (ISP) — принцип разделения интерфейса

Программные сущности не должны зависеть от методов, которые они не используют.
Когда ваш класс реализует интерфейс, ему могут достаться методы, которые совсем не нужны для его работы. Несмотря на это, их всё равно придётся реализовывать, иначе интерфейс будет считаться несоблюдённым. Если интерфейс по какой-то причине изменит сигнатуру этих методов или добавит новый, вам придётся вносить изменения в класс.
Для примера рассмотрим абстрактный класс Bird, который обязывает реализовать методы fly(), eat() и build_nest(). Создадим на его основе несколько птиц:

```python
from abc import ABC

class Bird(ABC):
    @abstractmethod
    def fly(self):
        pass

    @abstractmethod
    def build_nest(self):
        pass

    @abstractmethod
    def eat(self):
        pass

class Eagle(Bird):
    def fly():
        # лететь быстро и высоко

    def build_nest():
       # затаскивание веток на скалу

    def eat():
       # поедание вкусных мясных кусочков

class Colibri(Bird):
    def fly():
        # лететь, выписывая «восьмёрки»

    def build_nest():
       # построить гнездо из травинок и пуха
    
    def eat():
       # пить нектар 
```

Пока всё идёт хорошо. Теперь попробуем добавить Кукушку, которая не умеет вить гнёзда, или Пингвина, который не умеет летать.

```python
class Cuckoo(Bird):
    def fly():
        # летать от дерева к дереву

    def eat():
        # ловить гусениц 
```

При создании экземпляра Cuckoo вы получите ошибку TypeError: Can't instantiate abstract class Cuckoo with abstract methods build_nest. Абстрактный класс заставляет вас реализовывать ненужный кукушке метод. Чтобы избавиться от этой проблемы, разбейте класс на Bird, FlyingBird и NestingBird, распределив методы между ними. Теперь реализация кукушки может выглядеть так:

```python
class Cuckoo(FlyingBird, Bird):
    ...
```

ISP — это SRP для абстрактных классов и интерфейсов. Вместо создания «божественного абстрактного класса», выделите группы связанных атрибутов и методов и напишите для каждой отдельный класс. Подобным образом написаны, например, Class Based View в Django.
